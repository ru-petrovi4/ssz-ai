using ExCSS;
using Microsoft.Extensions.Logging;
using Ssz.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Ssz.AI.Models.AdvancedEmbeddingModel2;

/// <summary>
/// Класс для парсинга текста с морфологической разметкой и извлечения последовательностей слов.
/// Каждое слово представляется в формате: нормализованная_форма_часть_речи.
/// </summary>
public class MorphologicalTextParser
{
    // Регулярное выражение для поиска слов с морфологической разметкой в фигурных скобках.
    // Паттерн ищет: слово{информация}, где слово состоит из символов \w+, 
    // а информация - это всё содержимое до закрывающей фигурной скобки.
    private static readonly Regex WordPattern = new Regex(@"(\w+)\{([^}]+)\}", RegexOptions.Compiled);

    // Регулярное выражение для удаления XML-тегов из текста.
    // Паттерн ищет: <любые_символы>, где любые символы не содержат закрывающую угловую скобку.
    private static readonly Regex XmlTagPattern = new Regex(@"<[^>]+>", RegexOptions.Compiled);

    // Регулярное выражение для поиска первого непробельного символа.
    // Используется для определения знака препинания после слова.
    private static readonly Regex NonWhitespacePattern = new Regex(@"\S", RegexOptions.Compiled);

    private const char XmlTagReplacer = '|';

    /// <summary>
    /// Читает текстовый файл с морфологической разметкой и извлекает последовательности слов.
    /// 
    /// Алгоритм работы метода:
    /// 1. Считывает содержимое файла в строку.
    /// 2. Удаляет все XML-теги из текста.
    /// 3. Последовательно обрабатывает слова с морфологической разметкой.
    /// 4. Для каждого слова извлекает нормализованную форму и часть речи.
    /// 5. Формирует последовательности слов, которые:
    ///    - Начинаются с начала предложения
    ///    - Заканчиваются запятой или концом предложения (точка, восклицательный, вопросительный знак)
    /// 
    /// Формат входных данных:
    /// Слово{нормализованная_форма=часть_речи,характеристики|альтернативный_вариант}
    /// 
    /// Пример входных данных:
    /// "Опыты{опыт=S,муж,неод=вин,мн|опыт=S,муж,неод=им,мн} проводились{проводиться=V,несов=прош,мн}."
    /// 
    /// Формат выходных данных:
    /// Каждая последовательность - это список строк в формате: "нормализованная_форма_часть_речи"
    /// 
    /// Пример выходных данных:
    /// ["опыт_S", "проводиться_V"]
    /// </summary>
    /// <param name="filePath">Путь к файлу с размеченным текстом.</param>
    /// <returns>Список последовательностей, где каждая последовательность - это список слов в формате "слово_часть_речи".</returns>
    public static List<List<string>> ParseTextToSequences(string filePath)
    {
        // Создаем список для хранения всех найденных последовательностей слов.
        // Каждая последовательность представляет собой отдельный список строк.
        List<List<string>> sequences = new List<List<string>>();

        // Создаем список для хранения текущей формируемой последовательности.
        // По мере обработки текста мы добавляем слова в этот список,
        // а когда встречаем разделитель (запятую или конец предложения), 
        // добавляем эту последовательность в общий список и начинаем новую.
        List<string> currentSequence = new List<string>();

        // Считываем всё содержимое файла в строку.
        // Используем кодировку UTF-8 для корректной обработки кириллицы.
        string content = File.ReadAllText(filePath, Encoding.UTF8);

        // Удаляем все XML-теги из текста.
        // Заменяем каждый тег (всё что между < и >) на пробел,
        // чтобы не склеивать слова, которые были разделены тегом.
        string contentWithoutXml = XmlTagPattern.Replace(content, XmlTagReplacer.ToString());

        // Текущая позиция в строке, с которой мы начинаем поиск следующего слова.
        // Инициализируем нулем для начала обработки с начала строки.
        int position = 0;

        // Основной цикл обработки текста.
        // Продолжаем до тех пор, пока не дойдем до конца строки.
        while (position < contentWithoutXml.Length)
        {
            // Ищем следующее слово с морфологической разметкой, начиная с текущей позиции.
            // Match содержит информацию о найденном совпадении:
            // - Success: true, если совпадение найдено
            // - Index: позиция начала совпадения относительно начала поиска
            // - Groups: группы захвата из регулярного выражения
            Match match = WordPattern.Match(contentWithoutXml, position);

            // Если совпадение не найдено, значит мы обработали весь текст.
            // Выходим из цикла.
            if (!match.Success)
            {
                break;
            }

            // Извлекаем текст слова (первая группа захвата из регулярного выражения).
            // Это слово без фигурных скобок и информации внутри них.
            string wordText = match.Groups[1].Value;

            // Извлекаем информацию о слове (вторая группа захвата).
            // Это содержимое фигурных скобок с морфологической разметкой.
            string wordInfo = match.Groups[2].Value;            

            // Извлекаем нормализованную форму слова и часть речи из информации.
            // Метод возвращает кортеж (normalized, pos), если извлечение успешно,
            // или (null, null), если информация не содержит валидной морфологической разметки.
            var (normalized, pos) = ExtractNormalizedAndPos(wordInfo);

            // Если извлечение прошло успешно (оба значения не null),
            // добавляем слово в текущую последовательность.
            if (normalized != null && pos != null)
            {
                // Формируем строку в формате "нормализованная_форма_часть_речи"
                // и добавляем её в текущую последовательность.
                currentSequence.Add($"{normalized}_{pos}");
            }

            // Обновляем позицию: теперь она указывает на символ сразу после текущего слова.
            // match.Index - начало совпадения относительно начала строки.
            // match.Length - длина всего совпадения (слово + фигурные скобки).
            position = match.Index + match.Length;

            // Проверяем, есть ли знак препинания сразу после текущего слова.
            // Смотрим максимум на 10 символов вперед, чтобы найти первый непробельный символ.
            int lookAheadLength = Math.Min(10, contentWithoutXml.Length - position);

            // Если есть символы для проверки впереди.
            if (lookAheadLength > 0)
            {
                // Извлекаем подстроку для анализа.
                string textAhead = contentWithoutXml.Substring(position, lookAheadLength);

                // Ищем первый непробельный символ.
                Match nextCharMatch = NonWhitespacePattern.Match(textAhead);

                // Если нашли непробельный символ.
                if (nextCharMatch.Success)
                {
                    // Получаем этот символ.
                    char nextChar = nextCharMatch.Value[0];

                    // Проверяем, является ли этот символ знаком препинания,
                    // который завершает последовательность.                    
                    if (nextChar == XmlTagReplacer || nextChar == ',' || nextChar == '.' || nextChar == '!' || nextChar == '?' || nextChar == ';' || nextChar == ':' ||
                        nextChar == '«' || nextChar == '»' || nextChar == '"')
                    {
                        // Если текущая последовательность не пуста, завершаем её.
                        if (currentSequence.Count > 0)
                        {
                            // Добавляем последовательность в общий список.
                            sequences.Add(currentSequence);

                            // Создаем новую пустую последовательность.
                            currentSequence = new List<string>();
                        }
                    }
                }
            }
        }

        // После обработки всего текста проверяем, осталась ли незавершенная последовательность.
        // Если текущая последовательность содержит слова, добавляем её в общий список.
        if (currentSequence.Count > 0)
        {
            sequences.Add(currentSequence);
        }

        // Возвращаем список всех найденных последовательностей.
        return sequences;
    }

    /// <summary>
    /// выводит результаты.
    /// </summary>        
    public static void ShowInfo(List<List<string>> sequences, ILogger logger)
    {            
        // Выводим общее количество найденных последовательностей.
        logger.LogInformation($"Всего найдено последовательностей: {sequences.Count}");
        logger.LogInformation(@"");

        // Выводим первые 20 последовательностей для демонстрации результата.
        // Используем Math.Min для предотвращения выхода за границы списка,
        // если последовательностей меньше 20.
        int countToShow = Math.Min(20, sequences.Count);

        // Заголовок вывода.
        logger.LogInformation($"Первые {countToShow} последовательностей:");
        logger.LogInformation(new string('-', 80));

        // Цикл для вывода последовательностей.
        // Используем переменную i для нумерации (начиная с 0).
        for (int i = 0; i < countToShow; i = i + 1)
        {
            // Получаем текущую последовательность.
            List<string> sequence = sequences[i];

            // Объединяем все слова последовательности в одну строку через пробел.
            // string.Join принимает разделитель и коллекцию строк.
            string sequenceText = string.Join(" ", sequence);

            // Выводим номер последовательности (i + 1 для нумерации с 1) и её содержимое.
            // Используем интерполяцию строк ($"...") для удобного форматирования.
            logger.LogInformation($"{i + 1}. {sequenceText}");
        }
    }

    public static void WriteToFile(List<List<string>> sequences, string outputFilePath, ILogger logger)
    {            
        // Создаем StreamWriter для записи в файл с кодировкой UTF-8.
        // using обеспечивает автоматическое закрытие и освобождение ресурсов.
        using (StreamWriter writer = new StreamWriter(outputFilePath, false, new UTF8Encoding(true)))
        {
            // Записываем заголовок с общим количеством последовательностей.
            writer.WriteLine($"# Всего последовательностей: {sequences.Count}");
            writer.WriteLine();

            // Цикл по всем последовательностям для записи в файл.
            // Используем переменную index для нумерации.
            for (int index = 0; index < sequences.Count; index = index + 1)
            {
                // Получаем текущую последовательность.
                List<string> sequence = sequences[index];

                // Объединяем слова последовательности через пробел.
                string sequenceText = string.Join(" ", sequence);

                // Записываем последовательность в файл с номером.
                writer.WriteLine($"{sequenceText}");
            }
        }

        // Сообщаем пользователю об успешном сохранении результатов.
        logger.LogInformation(@"");
        logger.LogInformation($"Результаты сохранены в файл: {outputFilePath}");
    }

    public static List<string[]> LoadFromFile(string inputFilePath)
    {
        List<string[]> sequences = new(1000);

        using (StreamReader reader = new StreamReader(inputFilePath, Encoding.UTF8))
        {
            string? l;
            while ((l = reader.ReadLine()) is not null)
            {
                if (String.IsNullOrWhiteSpace(l) || l.StartsWith(@"#"))
                    continue;
                var words = l.Split(' ');
                sequences.Add(words);
            }
        }
        return sequences;
    }

    /// <summary>
    /// Извлекает нормализованную форму слова и часть речи из строки с морфологической информацией.
    /// 
    /// Формат входной строки:
    /// "нормализованная_форма=часть_речи,характеристики|альтернативный_вариант"
    /// 
    /// Правила извлечения:
    /// 1. Если в строке есть несколько вариантов (разделенных символом |), используется только первый вариант.
    /// 2. Из варианта извлекается нормализованная форма (до первого символа =).
    /// 3. Извлекается часть речи (после первого = и до первой запятой или второго =).
    /// 4. Нормализованная форма преобразуется в нижний регистр.
    /// 5. Если строка содержит технические метки (??) или не содержит символ =, возвращается (null, null).
    /// 
    /// Примеры:
    /// Вход: "опыт=S,муж,неод=вин,мн|опыт=S,муж,неод=им,мн"
    /// Выход: ("опыт", "S")
    /// 
    /// Вход: "цветной=A=вин,мн,полн,неод|цветной=A=им,мн,полн"
    /// Выход: ("цветной", "A")
    /// 
    /// Вход: "и=CONJ="
    /// Выход: ("и", "CONJ")
    /// 
    /// Вход: "xml??"
    /// Выход: (null, null)
    /// </summary>
    /// <param name="infoString">Строка с морфологической информацией из фигурных скобок.</param>
    /// <returns>Кортеж (нормализованная_форма, часть_речи) или (null, null), если извлечение невозможно.</returns>
    private static (string? normalized, string? pos) ExtractNormalizedAndPos(string infoString)
    {
        // Проверяем, содержит ли строка технические метки (??).
        // Такие строки относятся к XML-элементам и не содержат морфологической информации.
        // Если найдены технические метки, возвращаем (null, null).
        if (infoString.Contains("??"))
        {
            return (null, null);
        }

        // Если строка содержит несколько вариантов, разделенных символом |,
        // выбираем только первый вариант, как указано в требованиях задачи.
        // Split разбивает строку на массив подстрок по разделителю.
        // Берем первый элемент массива [0] - это первый вариант.
        string firstVariant = infoString.Split('|')[0];

        // Проверяем, содержит ли вариант символ =.
        // Если не содержит, значит это не морфологическая разметка, возвращаем (null, null).
        if (!firstVariant.Contains("="))
        {
            return (null, null);
        }

        // Ищем первое вхождение символа = в строке.
        // Это разделитель между нормализованной формой и остальной информацией.
        int firstEqualIndex = firstVariant.IndexOf('=');

        // Извлекаем нормализованную форму слова (всё до первого символа =).
        // Substring(0, firstEqualIndex) возвращает подстроку от начала до указанной позиции (не включая её).
        // ToLowerInvariant() преобразует строку в нижний регистр (инвариантная культура для производительности).
        string normalized = firstVariant.Substring(0, firstEqualIndex).ToLowerInvariant();

        // Извлекаем часть строки после первого символа = (информация о части речи и характеристиках).
        // Substring(firstEqualIndex + 1) возвращает подстроку, начиная с позиции после символа =.
        string remaining = firstVariant.Substring(firstEqualIndex + 1);

        // Ищем первую запятую в оставшейся части.
        // Запятая разделяет часть речи от дополнительных характеристик.
        int commaIndex = remaining.IndexOf(',');

        // Ищем второй символ = в оставшейся части.
        // Некоторые части речи имеют формат: часть_речи=характеристики (например, "A=вин,мн").
        int secondEqualIndex = remaining.IndexOf('=');

        // Переменная для хранения части речи.
        string pos;

        // Логика извлечения части речи зависит от формата строки.
        // Используется минимальная позиция разделителя, которая больше -1 (то есть найдена).

        // Если найдена запятая.
        if (commaIndex >= 0)
        {
            // Если также найден второй символ = и он идет раньше запятой,
            // то часть речи находится между первым = и вторым =.
            if (secondEqualIndex >= 0 && secondEqualIndex < commaIndex)
            {
                pos = remaining.Substring(0, secondEqualIndex);
            }
            else
            {
                // Иначе часть речи находится между первым = и первой запятой.
                pos = remaining.Substring(0, commaIndex);
            }
        }
        // Если запятая не найдена, но найден второй символ =.
        else if (secondEqualIndex >= 0)
        {
            // Часть речи находится между первым = и вторым =.
            pos = remaining.Substring(0, secondEqualIndex);
        }
        else
        {
            // Если нет ни запятой, ни второго =, то вся оставшаяся строка - это часть речи.
            // Это может быть случай, когда нет дополнительных характеристик.
            pos = remaining;
        }

        // Возвращаем кортеж с нормализованной формой и частью речи.
        return (normalized, pos);
    }        
}
