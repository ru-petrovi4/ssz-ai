// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/service_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Data.Experimental {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/service_config.proto</summary>
  public static partial class ServiceConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/service_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ServiceConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci10ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvc2VydmljZV9jb25maWcucHJv",
            "dG8SHHRlbnNvcmZsb3cuZGF0YS5leHBlcmltZW50YWwaK3RlbnNvcmZsb3cv",
            "Y29yZS9wcm90b2J1Zi9kYXRhX3NlcnZpY2UucHJvdG8ijQIKEERpc3BhdGNo",
            "ZXJDb25maWcSDAoEcG9ydBgBIAEoAxIQCghwcm90b2NvbBgCIAEoCRIQCgh3",
            "b3JrX2RpchgDIAEoCRIbChNmYXVsdF90b2xlcmFudF9tb2RlGAQgASgIEhgK",
            "EHdvcmtlcl9hZGRyZXNzZXMYByADKAkSOAoPZGVwbG95bWVudF9tb2RlGAkg",
            "ASgOMh8udGVuc29yZmxvdy5kYXRhLkRlcGxveW1lbnRNb2RlEiAKGGpvYl9n",
            "Y19jaGVja19pbnRlcnZhbF9tcxgFIAEoAxIZChFqb2JfZ2NfdGltZW91dF9t",
            "cxgGIAEoAxIZChFjbGllbnRfdGltZW91dF9tcxgIIAEoAyK+AgoMV29ya2Vy",
            "Q29uZmlnEgwKBHBvcnQYASABKAMSEAoIcHJvdG9jb2wYAiABKAkSGgoSZGlz",
            "cGF0Y2hlcl9hZGRyZXNzGAMgASgJEhYKDndvcmtlcl9hZGRyZXNzGAQgASgJ",
            "EhMKC3dvcmtlcl90YWdzGAogAygJEh0KFWhlYXJ0YmVhdF9pbnRlcnZhbF9t",
            "cxgFIAEoAxIdChVkaXNwYXRjaGVyX3RpbWVvdXRfbXMYBiABKAMSHgoWZGF0",
            "YV90cmFuc2Zlcl9wcm90b2NvbBgHIAEoCRIdChVkYXRhX3RyYW5zZmVyX2Fk",
            "ZHJlc3MYCCABKAkSJgoeY3Jvc3NfdHJhaW5lcl9jYWNoZV9zaXplX2J5dGVz",
            "GAsgASgDEiAKGHNodXRkb3duX3F1aWV0X3BlcmlvZF9tcxgJIAEoA0JXWlVn",
            "aXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy90ZW5zb3JmbG93L2dv",
            "L2NvcmUvcHJvdG9idWYvZm9yX2NvcmVfcHJvdG9zX2dvX3Byb3RvYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.Data.DataServiceReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Data.Experimental.DispatcherConfig), global::Tensorflow.Data.Experimental.DispatcherConfig.Parser, new[]{ "Port", "Protocol", "WorkDir", "FaultTolerantMode", "WorkerAddresses", "DeploymentMode", "JobGcCheckIntervalMs", "JobGcTimeoutMs", "ClientTimeoutMs" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Data.Experimental.WorkerConfig), global::Tensorflow.Data.Experimental.WorkerConfig.Parser, new[]{ "Port", "Protocol", "DispatcherAddress", "WorkerAddress", "WorkerTags", "HeartbeatIntervalMs", "DispatcherTimeoutMs", "DataTransferProtocol", "DataTransferAddress", "CrossTrainerCacheSizeBytes", "ShutdownQuietPeriodMs" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a tf.data service DispatchServer.
  /// Next id: 10
  /// </summary>
  public sealed partial class DispatcherConfig : pb::IMessage<DispatcherConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DispatcherConfig> _parser = new pb::MessageParser<DispatcherConfig>(() => new DispatcherConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DispatcherConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Data.Experimental.ServiceConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DispatcherConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DispatcherConfig(DispatcherConfig other) : this() {
      port_ = other.port_;
      protocol_ = other.protocol_;
      workDir_ = other.workDir_;
      faultTolerantMode_ = other.faultTolerantMode_;
      workerAddresses_ = other.workerAddresses_.Clone();
      deploymentMode_ = other.deploymentMode_;
      jobGcCheckIntervalMs_ = other.jobGcCheckIntervalMs_;
      jobGcTimeoutMs_ = other.jobGcTimeoutMs_;
      clientTimeoutMs_ = other.clientTimeoutMs_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DispatcherConfig Clone() {
      return new DispatcherConfig(this);
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 1;
    private long port_;
    /// <summary>
    /// The port for the dispatcher to bind to. A value of 0 indicates that the
    /// dispatcher may bind to any available port.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 2;
    private string protocol_ = "";
    /// <summary>
    /// The protocol for the dispatcher to use when connecting to workers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "work_dir" field.</summary>
    public const int WorkDirFieldNumber = 3;
    private string workDir_ = "";
    /// <summary>
    /// A work directory to use for storing dispatcher state, and for recovering
    /// during restarts. The empty string indicates not to use any work directory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkDir {
      get { return workDir_; }
      set {
        workDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "fault_tolerant_mode" field.</summary>
    public const int FaultTolerantModeFieldNumber = 4;
    private bool faultTolerantMode_;
    /// <summary>
    /// Whether to run in fault tolerant mode, where dispatcher state is saved
    /// across restarts. Requires that `work_dir` is nonempty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FaultTolerantMode {
      get { return faultTolerantMode_; }
      set {
        faultTolerantMode_ = value;
      }
    }

    /// <summary>Field number for the "worker_addresses" field.</summary>
    public const int WorkerAddressesFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_workerAddresses_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> workerAddresses_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
    /// of worker addresses that will register with the dispatcher. The worker
    /// addresses should be in the format "host" or "host:port", where "port" is an
    /// integer, named port, or %port% to match any port.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> WorkerAddresses {
      get { return workerAddresses_; }
    }

    /// <summary>Field number for the "deployment_mode" field.</summary>
    public const int DeploymentModeFieldNumber = 9;
    private global::Tensorflow.Data.DeploymentMode deploymentMode_ = global::Tensorflow.Data.DeploymentMode.Unspecified;
    /// <summary>
    /// (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
    /// "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Tensorflow.Data.DeploymentMode DeploymentMode {
      get { return deploymentMode_; }
      set {
        deploymentMode_ = value;
      }
    }

    /// <summary>Field number for the "job_gc_check_interval_ms" field.</summary>
    public const int JobGcCheckIntervalMsFieldNumber = 5;
    private long jobGcCheckIntervalMs_;
    /// <summary>
    /// How often the dispatcher should scan through to delete old and unused
    /// jobs. A value of 0 indicates that the decision should be left up to the
    /// runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long JobGcCheckIntervalMs {
      get { return jobGcCheckIntervalMs_; }
      set {
        jobGcCheckIntervalMs_ = value;
      }
    }

    /// <summary>Field number for the "job_gc_timeout_ms" field.</summary>
    public const int JobGcTimeoutMsFieldNumber = 6;
    private long jobGcTimeoutMs_;
    /// <summary>
    /// How long a job needs to be unused before it becomes a candidate for garbage
    /// collection. A value of -1 indicates that jobs should never be garbage
    /// collected. A value of 0 indicates that the decision should be left up to
    /// the runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long JobGcTimeoutMs {
      get { return jobGcTimeoutMs_; }
      set {
        jobGcTimeoutMs_ = value;
      }
    }

    /// <summary>Field number for the "client_timeout_ms" field.</summary>
    public const int ClientTimeoutMsFieldNumber = 8;
    private long clientTimeoutMs_;
    /// <summary>
    /// How long to wait before garbage-collecting a client that hasn't
    /// heartbeated to the dispatcher. A value of 0 indicates that the timeout
    /// should be left to the runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ClientTimeoutMs {
      get { return clientTimeoutMs_; }
      set {
        clientTimeoutMs_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DispatcherConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DispatcherConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Port != other.Port) return false;
      if (Protocol != other.Protocol) return false;
      if (WorkDir != other.WorkDir) return false;
      if (FaultTolerantMode != other.FaultTolerantMode) return false;
      if(!workerAddresses_.Equals(other.workerAddresses_)) return false;
      if (DeploymentMode != other.DeploymentMode) return false;
      if (JobGcCheckIntervalMs != other.JobGcCheckIntervalMs) return false;
      if (JobGcTimeoutMs != other.JobGcTimeoutMs) return false;
      if (ClientTimeoutMs != other.ClientTimeoutMs) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Port != 0L) hash ^= Port.GetHashCode();
      if (Protocol.Length != 0) hash ^= Protocol.GetHashCode();
      if (WorkDir.Length != 0) hash ^= WorkDir.GetHashCode();
      if (FaultTolerantMode != false) hash ^= FaultTolerantMode.GetHashCode();
      hash ^= workerAddresses_.GetHashCode();
      if (DeploymentMode != global::Tensorflow.Data.DeploymentMode.Unspecified) hash ^= DeploymentMode.GetHashCode();
      if (JobGcCheckIntervalMs != 0L) hash ^= JobGcCheckIntervalMs.GetHashCode();
      if (JobGcTimeoutMs != 0L) hash ^= JobGcTimeoutMs.GetHashCode();
      if (ClientTimeoutMs != 0L) hash ^= ClientTimeoutMs.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Port != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Port);
      }
      if (Protocol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (WorkDir.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(WorkDir);
      }
      if (FaultTolerantMode != false) {
        output.WriteRawTag(32);
        output.WriteBool(FaultTolerantMode);
      }
      if (JobGcCheckIntervalMs != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(JobGcCheckIntervalMs);
      }
      if (JobGcTimeoutMs != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(JobGcTimeoutMs);
      }
      workerAddresses_.WriteTo(output, _repeated_workerAddresses_codec);
      if (ClientTimeoutMs != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(ClientTimeoutMs);
      }
      if (DeploymentMode != global::Tensorflow.Data.DeploymentMode.Unspecified) {
        output.WriteRawTag(72);
        output.WriteEnum((int) DeploymentMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Port != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Port);
      }
      if (Protocol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (WorkDir.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(WorkDir);
      }
      if (FaultTolerantMode != false) {
        output.WriteRawTag(32);
        output.WriteBool(FaultTolerantMode);
      }
      if (JobGcCheckIntervalMs != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(JobGcCheckIntervalMs);
      }
      if (JobGcTimeoutMs != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(JobGcTimeoutMs);
      }
      workerAddresses_.WriteTo(ref output, _repeated_workerAddresses_codec);
      if (ClientTimeoutMs != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(ClientTimeoutMs);
      }
      if (DeploymentMode != global::Tensorflow.Data.DeploymentMode.Unspecified) {
        output.WriteRawTag(72);
        output.WriteEnum((int) DeploymentMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Port != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Port);
      }
      if (Protocol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (WorkDir.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkDir);
      }
      if (FaultTolerantMode != false) {
        size += 1 + 1;
      }
      size += workerAddresses_.CalculateSize(_repeated_workerAddresses_codec);
      if (DeploymentMode != global::Tensorflow.Data.DeploymentMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DeploymentMode);
      }
      if (JobGcCheckIntervalMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(JobGcCheckIntervalMs);
      }
      if (JobGcTimeoutMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(JobGcTimeoutMs);
      }
      if (ClientTimeoutMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ClientTimeoutMs);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DispatcherConfig other) {
      if (other == null) {
        return;
      }
      if (other.Port != 0L) {
        Port = other.Port;
      }
      if (other.Protocol.Length != 0) {
        Protocol = other.Protocol;
      }
      if (other.WorkDir.Length != 0) {
        WorkDir = other.WorkDir;
      }
      if (other.FaultTolerantMode != false) {
        FaultTolerantMode = other.FaultTolerantMode;
      }
      workerAddresses_.Add(other.workerAddresses_);
      if (other.DeploymentMode != global::Tensorflow.Data.DeploymentMode.Unspecified) {
        DeploymentMode = other.DeploymentMode;
      }
      if (other.JobGcCheckIntervalMs != 0L) {
        JobGcCheckIntervalMs = other.JobGcCheckIntervalMs;
      }
      if (other.JobGcTimeoutMs != 0L) {
        JobGcTimeoutMs = other.JobGcTimeoutMs;
      }
      if (other.ClientTimeoutMs != 0L) {
        ClientTimeoutMs = other.ClientTimeoutMs;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Port = input.ReadInt64();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            WorkDir = input.ReadString();
            break;
          }
          case 32: {
            FaultTolerantMode = input.ReadBool();
            break;
          }
          case 40: {
            JobGcCheckIntervalMs = input.ReadInt64();
            break;
          }
          case 48: {
            JobGcTimeoutMs = input.ReadInt64();
            break;
          }
          case 58: {
            workerAddresses_.AddEntriesFrom(input, _repeated_workerAddresses_codec);
            break;
          }
          case 64: {
            ClientTimeoutMs = input.ReadInt64();
            break;
          }
          case 72: {
            DeploymentMode = (global::Tensorflow.Data.DeploymentMode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Port = input.ReadInt64();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            WorkDir = input.ReadString();
            break;
          }
          case 32: {
            FaultTolerantMode = input.ReadBool();
            break;
          }
          case 40: {
            JobGcCheckIntervalMs = input.ReadInt64();
            break;
          }
          case 48: {
            JobGcTimeoutMs = input.ReadInt64();
            break;
          }
          case 58: {
            workerAddresses_.AddEntriesFrom(ref input, _repeated_workerAddresses_codec);
            break;
          }
          case 64: {
            ClientTimeoutMs = input.ReadInt64();
            break;
          }
          case 72: {
            DeploymentMode = (global::Tensorflow.Data.DeploymentMode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for a tf.data service WorkerServer.
  /// Next id: 12
  /// </summary>
  public sealed partial class WorkerConfig : pb::IMessage<WorkerConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WorkerConfig> _parser = new pb::MessageParser<WorkerConfig>(() => new WorkerConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<WorkerConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Data.Experimental.ServiceConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WorkerConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WorkerConfig(WorkerConfig other) : this() {
      port_ = other.port_;
      protocol_ = other.protocol_;
      dispatcherAddress_ = other.dispatcherAddress_;
      workerAddress_ = other.workerAddress_;
      workerTags_ = other.workerTags_.Clone();
      heartbeatIntervalMs_ = other.heartbeatIntervalMs_;
      dispatcherTimeoutMs_ = other.dispatcherTimeoutMs_;
      dataTransferProtocol_ = other.dataTransferProtocol_;
      dataTransferAddress_ = other.dataTransferAddress_;
      crossTrainerCacheSizeBytes_ = other.crossTrainerCacheSizeBytes_;
      shutdownQuietPeriodMs_ = other.shutdownQuietPeriodMs_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WorkerConfig Clone() {
      return new WorkerConfig(this);
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 1;
    private long port_;
    /// <summary>
    /// The port for the worker to bind to. A value of 0 indicates that the
    /// worker may bind to any available port.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 2;
    private string protocol_ = "";
    /// <summary>
    /// The protocol for the worker to use when connecting to the dispatcher.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dispatcher_address" field.</summary>
    public const int DispatcherAddressFieldNumber = 3;
    private string dispatcherAddress_ = "";
    /// <summary>
    /// The address of the dispatcher to register with.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DispatcherAddress {
      get { return dispatcherAddress_; }
      set {
        dispatcherAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "worker_address" field.</summary>
    public const int WorkerAddressFieldNumber = 4;
    private string workerAddress_ = "";
    /// <summary>
    /// The address of the worker server. The substring "%port%", if specified,
    /// will be replaced with the worker's bound port. This is useful when the port
    /// is set to `0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkerAddress {
      get { return workerAddress_; }
      set {
        workerAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "worker_tags" field.</summary>
    public const int WorkerTagsFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_workerTags_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> workerTags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Tags attached to the worker. This allows reading from selected workers.
    /// For example, by applying a "COLOCATED" tag, tf.data service is able to read
    /// from the local tf.data worker if one exists, then from off-TF-host workers,
    /// to avoid cross-TF-host reads.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> WorkerTags {
      get { return workerTags_; }
    }

    /// <summary>Field number for the "heartbeat_interval_ms" field.</summary>
    public const int HeartbeatIntervalMsFieldNumber = 5;
    private long heartbeatIntervalMs_;
    /// <summary>
    /// How often the worker should heartbeat to the master. A value of 0 indicates
    /// that the decision should be left up to the runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HeartbeatIntervalMs {
      get { return heartbeatIntervalMs_; }
      set {
        heartbeatIntervalMs_ = value;
      }
    }

    /// <summary>Field number for the "dispatcher_timeout_ms" field.</summary>
    public const int DispatcherTimeoutMsFieldNumber = 6;
    private long dispatcherTimeoutMs_;
    /// <summary>
    /// How long to retry requests to the dispatcher before giving up and reporting
    /// an error. A value of 0 indicates that the decision should be left up to the
    /// runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long DispatcherTimeoutMs {
      get { return dispatcherTimeoutMs_; }
      set {
        dispatcherTimeoutMs_ = value;
      }
    }

    /// <summary>Field number for the "data_transfer_protocol" field.</summary>
    public const int DataTransferProtocolFieldNumber = 7;
    private string dataTransferProtocol_ = "";
    /// <summary>
    /// The protocol for the worker to use when transferring data to clients.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DataTransferProtocol {
      get { return dataTransferProtocol_; }
      set {
        dataTransferProtocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data_transfer_address" field.</summary>
    public const int DataTransferAddressFieldNumber = 8;
    private string dataTransferAddress_ = "";
    /// <summary>
    /// The data transfer address of the worker server. The substring "%port%", if
    /// specified, will be replaced with the worker's bound port. This is useful
    /// when the port is set to `0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DataTransferAddress {
      get { return dataTransferAddress_; }
      set {
        dataTransferAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cross_trainer_cache_size_bytes" field.</summary>
    public const int CrossTrainerCacheSizeBytesFieldNumber = 11;
    private long crossTrainerCacheSizeBytes_;
    /// <summary>
    /// Maximum size of the cross-trainer cache in bytes. If enabled, make sure
    /// your training job provides sufficient memory resources.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long CrossTrainerCacheSizeBytes {
      get { return crossTrainerCacheSizeBytes_; }
      set {
        crossTrainerCacheSizeBytes_ = value;
      }
    }

    /// <summary>Field number for the "shutdown_quiet_period_ms" field.</summary>
    public const int ShutdownQuietPeriodMsFieldNumber = 9;
    private long shutdownQuietPeriodMs_;
    /// <summary>
    /// When shutting down a worker, how long to wait for the gRPC server to
    /// process the final requests. This is used to achieve clean shutdown in unit
    /// tests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShutdownQuietPeriodMs {
      get { return shutdownQuietPeriodMs_; }
      set {
        shutdownQuietPeriodMs_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as WorkerConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(WorkerConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Port != other.Port) return false;
      if (Protocol != other.Protocol) return false;
      if (DispatcherAddress != other.DispatcherAddress) return false;
      if (WorkerAddress != other.WorkerAddress) return false;
      if(!workerTags_.Equals(other.workerTags_)) return false;
      if (HeartbeatIntervalMs != other.HeartbeatIntervalMs) return false;
      if (DispatcherTimeoutMs != other.DispatcherTimeoutMs) return false;
      if (DataTransferProtocol != other.DataTransferProtocol) return false;
      if (DataTransferAddress != other.DataTransferAddress) return false;
      if (CrossTrainerCacheSizeBytes != other.CrossTrainerCacheSizeBytes) return false;
      if (ShutdownQuietPeriodMs != other.ShutdownQuietPeriodMs) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Port != 0L) hash ^= Port.GetHashCode();
      if (Protocol.Length != 0) hash ^= Protocol.GetHashCode();
      if (DispatcherAddress.Length != 0) hash ^= DispatcherAddress.GetHashCode();
      if (WorkerAddress.Length != 0) hash ^= WorkerAddress.GetHashCode();
      hash ^= workerTags_.GetHashCode();
      if (HeartbeatIntervalMs != 0L) hash ^= HeartbeatIntervalMs.GetHashCode();
      if (DispatcherTimeoutMs != 0L) hash ^= DispatcherTimeoutMs.GetHashCode();
      if (DataTransferProtocol.Length != 0) hash ^= DataTransferProtocol.GetHashCode();
      if (DataTransferAddress.Length != 0) hash ^= DataTransferAddress.GetHashCode();
      if (CrossTrainerCacheSizeBytes != 0L) hash ^= CrossTrainerCacheSizeBytes.GetHashCode();
      if (ShutdownQuietPeriodMs != 0L) hash ^= ShutdownQuietPeriodMs.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Port != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Port);
      }
      if (Protocol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (DispatcherAddress.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DispatcherAddress);
      }
      if (WorkerAddress.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(WorkerAddress);
      }
      if (HeartbeatIntervalMs != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(HeartbeatIntervalMs);
      }
      if (DispatcherTimeoutMs != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(DispatcherTimeoutMs);
      }
      if (DataTransferProtocol.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(DataTransferProtocol);
      }
      if (DataTransferAddress.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(DataTransferAddress);
      }
      if (ShutdownQuietPeriodMs != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(ShutdownQuietPeriodMs);
      }
      workerTags_.WriteTo(output, _repeated_workerTags_codec);
      if (CrossTrainerCacheSizeBytes != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(CrossTrainerCacheSizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Port != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Port);
      }
      if (Protocol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (DispatcherAddress.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DispatcherAddress);
      }
      if (WorkerAddress.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(WorkerAddress);
      }
      if (HeartbeatIntervalMs != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(HeartbeatIntervalMs);
      }
      if (DispatcherTimeoutMs != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(DispatcherTimeoutMs);
      }
      if (DataTransferProtocol.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(DataTransferProtocol);
      }
      if (DataTransferAddress.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(DataTransferAddress);
      }
      if (ShutdownQuietPeriodMs != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(ShutdownQuietPeriodMs);
      }
      workerTags_.WriteTo(ref output, _repeated_workerTags_codec);
      if (CrossTrainerCacheSizeBytes != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(CrossTrainerCacheSizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Port != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Port);
      }
      if (Protocol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (DispatcherAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DispatcherAddress);
      }
      if (WorkerAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkerAddress);
      }
      size += workerTags_.CalculateSize(_repeated_workerTags_codec);
      if (HeartbeatIntervalMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HeartbeatIntervalMs);
      }
      if (DispatcherTimeoutMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DispatcherTimeoutMs);
      }
      if (DataTransferProtocol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DataTransferProtocol);
      }
      if (DataTransferAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DataTransferAddress);
      }
      if (CrossTrainerCacheSizeBytes != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(CrossTrainerCacheSizeBytes);
      }
      if (ShutdownQuietPeriodMs != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShutdownQuietPeriodMs);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(WorkerConfig other) {
      if (other == null) {
        return;
      }
      if (other.Port != 0L) {
        Port = other.Port;
      }
      if (other.Protocol.Length != 0) {
        Protocol = other.Protocol;
      }
      if (other.DispatcherAddress.Length != 0) {
        DispatcherAddress = other.DispatcherAddress;
      }
      if (other.WorkerAddress.Length != 0) {
        WorkerAddress = other.WorkerAddress;
      }
      workerTags_.Add(other.workerTags_);
      if (other.HeartbeatIntervalMs != 0L) {
        HeartbeatIntervalMs = other.HeartbeatIntervalMs;
      }
      if (other.DispatcherTimeoutMs != 0L) {
        DispatcherTimeoutMs = other.DispatcherTimeoutMs;
      }
      if (other.DataTransferProtocol.Length != 0) {
        DataTransferProtocol = other.DataTransferProtocol;
      }
      if (other.DataTransferAddress.Length != 0) {
        DataTransferAddress = other.DataTransferAddress;
      }
      if (other.CrossTrainerCacheSizeBytes != 0L) {
        CrossTrainerCacheSizeBytes = other.CrossTrainerCacheSizeBytes;
      }
      if (other.ShutdownQuietPeriodMs != 0L) {
        ShutdownQuietPeriodMs = other.ShutdownQuietPeriodMs;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Port = input.ReadInt64();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            DispatcherAddress = input.ReadString();
            break;
          }
          case 34: {
            WorkerAddress = input.ReadString();
            break;
          }
          case 40: {
            HeartbeatIntervalMs = input.ReadInt64();
            break;
          }
          case 48: {
            DispatcherTimeoutMs = input.ReadInt64();
            break;
          }
          case 58: {
            DataTransferProtocol = input.ReadString();
            break;
          }
          case 66: {
            DataTransferAddress = input.ReadString();
            break;
          }
          case 72: {
            ShutdownQuietPeriodMs = input.ReadInt64();
            break;
          }
          case 82: {
            workerTags_.AddEntriesFrom(input, _repeated_workerTags_codec);
            break;
          }
          case 88: {
            CrossTrainerCacheSizeBytes = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Port = input.ReadInt64();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            DispatcherAddress = input.ReadString();
            break;
          }
          case 34: {
            WorkerAddress = input.ReadString();
            break;
          }
          case 40: {
            HeartbeatIntervalMs = input.ReadInt64();
            break;
          }
          case 48: {
            DispatcherTimeoutMs = input.ReadInt64();
            break;
          }
          case 58: {
            DataTransferProtocol = input.ReadString();
            break;
          }
          case 66: {
            DataTransferAddress = input.ReadString();
            break;
          }
          case 72: {
            ShutdownQuietPeriodMs = input.ReadInt64();
            break;
          }
          case 82: {
            workerTags_.AddEntriesFrom(ref input, _repeated_workerTags_codec);
            break;
          }
          case 88: {
            CrossTrainerCacheSizeBytes = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
